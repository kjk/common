package appendstore

import (
	"bytes"
	"fmt"
	"strings"
)

// serialize key/value pairs in a simple, single-line format
func KeyValueMarshal(keyValues ...string) (string, error) {
	if len(keyValues)%2 != 0 {
		return "", fmt.Errorf("odd number of key-value pairs")
	}
	var buf bytes.Buffer
	for i := 0; i < len(keyValues); i += 2 {
		key := keyValues[i]
		if strings.ContainsAny(key, ": \n\r\t\"") {
			return "", fmt.Errorf("key '%s' contains space, tab, newline, or ':'", key)
		}
		if i > 0 {
			buf.WriteByte(' ')
		}
		buf.WriteString(key)
		buf.WriteByte(':')
		v := keyValues[i+1]
		if !strings.ContainsAny(v, " \n\r\t\"") {
			buf.WriteString(v)
			continue
		}
		// needs escaping
		buf.WriteByte('"')
		for _, r := range v {
			if r == '"' || r == '\\' || r == '\n' || r == '\r' || r == '\t' {
				buf.WriteByte('\\')
				switch r {
				case '"', '\\':
					buf.WriteRune(r)
				case '\n':
					buf.WriteByte('n')
				case '\r':
					buf.WriteByte('r')
				case '\t':
					buf.WriteByte('t')
				default:
					panic("invalid state")
				}
			} else {
				buf.WriteRune(r)
			}
		}
		buf.WriteByte('"')
	}
	return buf.String(), nil
}

// parse key/value single-line format generated by KeyValueMarshal
func KeyValueUnmarshal(str string) ([]string, error) {
	var res []string
	s := str
	for len(s) > 0 {
		keyEnd := strings.IndexByte(s, ':')
		if keyEnd == -1 {
			return nil, fmt.Errorf("didn't find ':' in '%s' indicating end of key", str)
		}
		// key
		push(&res, s[:keyEnd])
		s = s[keyEnd+1:]
		if len(s) == 0 {
			// we allow empty values
			push(&res, "")
			return res, nil
		}

		if s[0] == '"' {
			// value is escaped
			s = s[1:]

			var buf bytes.Buffer
			buf.Grow(len(s))
			for i := 0; i < len(s); i++ {
				c := s[i]
				switch c {
				case '\\':
					i++
					if i >= len(s) {
						return nil, fmt.Errorf("bad value escaping in '%s'", str)
					}
					switch s[i] {
					case '"', '\\':
						buf.WriteByte(s[i])
					case 'n':
						buf.WriteByte('\n')
					case 'r':
						buf.WriteByte('\r')
					case 't':
						buf.WriteByte('\t')
					default:
						return nil, fmt.Errorf("unknown escape sequence '\\%c' in '%s'", s[i], str)
					}
				case '"':
					// end of escaped value
					v := buf.String()
					push(&res, v)
					s = s[i+1:]
					if len(s) == 0 {
						return res, nil
					}
					if s[0] != 0 {
						return nil, fmt.Errorf("unexpected character '%c' after value in '%s'", s[0], str)
					}
					s = s[1:]
				default:
					buf.WriteByte(s[i])
				}
			}
			return nil, fmt.Errorf("unexpected end of escaped value in '%s'", str)
		}
		// unescaped value, ends with space or end of string
		valEnd := strings.IndexByte(s, ' ')
		if valEnd == -1 {
			push(&res, s)
			return res, nil
		}
		push(&res, s[:valEnd])
		s = s[valEnd:]
		if len(s) == 0 {
			return res, nil
		}
		if s[0] != ' ' {
			return nil, fmt.Errorf("expected ' ' but got '%c' after value in '%s'", s[0], str)
		}
		s = s[1:]
	}
	return res, nil
}

func push[S ~[]E, E any](s *S, els ...E) {
	*s = append(*s, els...)
}
