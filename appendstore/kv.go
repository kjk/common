package appendstore

import (
	"bytes"
	"fmt"
	"strings"
)

// serialize key/value pairs in a simple, single-line format
func KeyValueMarshal(keyValues ...string) (string, error) {
	if len(keyValues)%2 != 0 {
		return "", fmt.Errorf("odd number of key-value pairs")
	}
	var buf bytes.Buffer
	for i := 0; i < len(keyValues); i += 2 {
		key := keyValues[i]
		if strings.Contains(key, " ") || strings.Contains(key, "\n") {
			return "", fmt.Errorf("key '%s' contains space or newline", key)
		}
		if i > 0 {
			buf.WriteByte(' ')
		}
		buf.WriteString(key)
		buf.WriteByte(':')
		v := keyValues[i+1]
		if strings.Contains(v, " ") || strings.Contains(v, "\n") || strings.HasPrefix(v, "\"") {
			// needs escaping
			buf.WriteByte('"')
			for _, r := range v {
				if r == '"' || r == '\\' || r == '\n' {
					buf.WriteByte('\\')
					switch r {
					case '"', '\\':
						buf.WriteRune(r)
					case '\n':
						buf.WriteByte('n')
					default:
						panic("invalid state")
					}
				} else {
					buf.WriteRune(r)
				}
			}
			buf.WriteByte('"')
		} else {
			buf.WriteString(v)
		}
	}
	return buf.String(), nil
}

// parse key/value single-line format generated by KeyValueMarshal
func KeyValueUnmarshal(str string) ([]string, error) {
	var res []string
	s := str
	for len(s) > 0 {
		keyEnd := strings.IndexByte(s, ':')
		if keyEnd == -1 {
			return nil, fmt.Errorf("didn't find ':' in '%s' indicating end of key", str)
		}
		// key
		push(&res, s[:keyEnd])
		s = s[keyEnd+1:]
		if len(s) == 0 {
			// we allow empty values
			push(&res, "")
			return res, nil
		}

		if s[0] == '"' {
			// value is escaped
			s = s[1:]

			var buf bytes.Buffer
			for i := 0; i < len(s); i++ {
				c := s[i]
				switch c {
				case '\\':
					i++
					if i >= len(s) {
						return nil, fmt.Errorf("bad value escaping in '%s'", str)
					}
					switch s[i] {
					case '"', '\\':
						buf.WriteByte(s[i])
					case 'n':
						buf.WriteByte('\n')
					default:
						return nil, fmt.Errorf("unknown escape sequence '\\%c' in '%s'", s[i], str)
					}
				case '"':
					// end of escaped value
					v := buf.String()
					push(&res, v)
					s = s[i+1:]
					if len(s) == 0 {
						return res, nil
					}
					if s[0] != 0 {
						return nil, fmt.Errorf("unexpected character '%c' after value in '%s'", s[0], str)
					}
					s = s[1:]
				default:
					buf.WriteByte(s[i])
				}
			}
			return nil, fmt.Errorf("unexpected end of escaped value in '%s'", str)
		}
		// unescaped value, ends with space or end of string
		valEnd := strings.IndexByte(s, ' ')
		if valEnd == -1 {
			push(&res, s)
			return res, nil
		}
		push(&res, s[:valEnd])
		s = s[valEnd:]
		if len(s) == 0 {
			return res, nil
		}
		if s[0] != ' ' {
			return nil, fmt.Errorf("expected ' ' but got '%c' after value in '%s'", s[0], str)
		}
		s = s[1:]
	}
	return res, nil
}

func push[S ~[]E, E any](s *S, els ...E) {
	*s = append(*s, els...)
}
